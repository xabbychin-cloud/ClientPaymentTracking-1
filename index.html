<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Google Sign-In Test</title>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import { 
      getAuth, GoogleAuthProvider, signInWithRedirect, getRedirectResult, onAuthStateChanged 
    } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "client-payment-tracker-3572b.firebaseapp.com",
      projectId: "client-payment-tracker-3572b",
      storageBucket: "client-payment-tracker-3572b.appspot.com",
      messagingSenderId: "151091330895",
      appId: "1:151091330895:web:d23440ad57a386da720f3a"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const provider = new GoogleAuthProvider();

    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("googleLoginBtn").addEventListener("click", () => {
        signInWithRedirect(auth, provider);
      });

      getRedirectResult(auth)
        .then((result) => {
          if (result.user) {
            console.log("Signed in as:", result.user.displayName);
          }
        })
        .catch((error) => {
          console.error("Redirect error:", error);
        });

      onAuthStateChanged(auth, (user) => {
        if (user) {
          console.log("Auth state:", user.email);
        } else {
          console.log("No user signed in");
        }
      });
    });
  </script>
</head>
<body>
  <button id="googleLoginBtn">Sign in with Google</button>
</body>
</html>


    <!-- Charge Form -->
    <form id="chargeForm">
      <input id="chargeFirstName" placeholder="First Name" required>
      <input id="chargeLastName" placeholder="Last Name" required>
      <input id="chargeAmount" type="number" placeholder="Amount" required>
      <input id="chargeRemarks" placeholder="Remarks">
      <button type="submit">Add Charge</button>
    </form>

    <!-- Payment Form -->
    <form id="paymentForm">
      <input id="firstName" placeholder="First Name" required>
      <input id="lastName" placeholder="Last Name" required>
      <input id="amount" type="number" placeholder="Amount" required>
      <input id="method" placeholder="Payment Method">
      <input id="remarks" placeholder="Remarks">
      <button type="submit">Add Payment</button>
    </form>

    <!-- Filter Buttons -->
    <button id="filterAll">All</button>
    <button id="filterOutstanding">Outstanding</button>
    <button id="filterPaid">Paid</button>

    <!-- Search Bar -->
    <input id="searchBox" placeholder="Search by name or remarks">

    <!-- Clients Table -->
    <table id="clientsTable">
      <thead>
        <tr>
          <th>ID</th>
          <th>Name</th>
          <th>Debit</th>
          <th>Credit</th>
          <th>Balance</th>
          <th>Status</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <!-- Modal for Viewing Client Records -->
    <div id="viewModal" class="modal">
      <div class="modal-content">
        <span class="close" id="closeModal">&times;</span>
        <h2 id="modalTitle">Client Records</h2>
        <div id="modalSummary">
          <p><strong>Total Debit:</strong> <span id="totalDebit"></span></p>
          <p><strong>Total Credit:</strong> <span id="totalCredit"></span></p>
          <p><strong>Balance:</strong> <span id="balance"></span></p>
          <p><strong>Status:</strong> <span id="status"></span></p>
        </div>
        <h3>Transaction History</h3>
        <table class="history-table" id="historyTable">
          <thead>
            <tr>
              <th>Date</th>
              <th>Debit</th>
              <th>Credit</th>
              <th>Method</th>
              <th>Remarks</th>
            </tr>
          </thead>
          <tbody id="historyBody"></tbody>
        </table>
      </div>
    </div>

    <button id="logoutBtn">Logout</button>
  </div>

  <!-- Firebase & Script -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import { 
      getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, GoogleAuthProvider, signInWithRedirect, getRedirectResult 
    } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
    import { 
      getFirestore, doc, getDoc, setDoc, onSnapshot, collection,
      enableIndexedDbPersistence 
    } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "client-payment-tracker-3572b.firebaseapp.com",
      projectId: "client-payment-tracker-3572b",
      storageBucket: "client-payment-tracker-3572b.appspot.com",
      messagingSenderId: "151091330895",
      appId: "1:151091330895:web:d23440ad57a386da720f3a"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const provider = new GoogleAuthProvider();

    onAuthStateChanged(auth, (user) => {
  if (user) {
    console.log("User signed in:", user.displayName, user.email);
  } else {
    console.log("No user signed in");
  }
});


    // ✅ Enable offline persistence
    enableIndexedDbPersistence(db).catch((err) => {
      if (err.code === 'failed-precondition') {
        console.error("Persistence failed: multiple tabs open");
      } else if (err.code === 'unimplemented') {
        console.error("Persistence not supported by this browser");
      }
    });

    let currentUser = null;
    let clients = {};
    let currentFilter = "all";
    let searchQuery = "";

    // Function to generate client ID based on name (assuming unique names)
    function generateClientId(first, last) {
      return `${first}_${last}`.replace(/\s+/g, '_').toLowerCase();
    }

    // --- Auth Functions ---
    function showAuthContainer() {
      document.getElementById("authContainer").style.display = "block";
      document.getElementById("appContainer").style.display = "none";
    }

    function showAppContainer() {
      document.getElementById("authContainer").style.display = "none";
      document.getElementById("appContainer").style.display = "block";
    }

    // Handle redirect result on page load
    getRedirectResult(auth).then((result) => {
      if (result.user) {
        console.log("Signed in with Google via redirect:", result.user);
      }
    }).catch((error) => {
      console.error("Redirect sign-in error:", error);
    });

    // Google Sign-In (Redirect)
    document.getElementById("googleSignInBtn").addEventListener("click", async () => {
      try {
        await signInWithRedirect(auth, provider);
        // No need for alert here; the redirect will handle it
      } catch (err) {
        alert("Google sign-in failed: " + err.message);
      }
    });

    // Login
    document.getElementById("loginBtn").addEventListener("click", async () => {
      const email = document.getElementById("loginEmail").value;
      const password = document.getElementById("loginPassword").value;
      try {
        await signInWithEmailAndPassword(auth, email, password);
        alert("Logged in successfully!");
      } catch (err) {
        alert("Login failed: " + err.message);
      }
    });

    // Signup
    document.getElementById("signupBtn").addEventListener("click", async () => {
      const email = document.getElementById("signupEmail").value;
      const password = document.getElementById("signupPassword").value;
      try {
        await createUserWithEmailAndPassword(auth, email, password);
        alert("Account created successfully!");
      } catch (err) {
        alert("Signup failed: " + err.message);
      }
    });

    // Toggle forms
    document.getElementById("showSignup").addEventListener("click", () => {
      document.getElementById("loginForm").style.display = "none";
      document.getElementById("signupForm").style.display = "block";
    });
    document.getElementById("showLogin").addEventListener("click", () => {
      document.getElementById("signupForm").style.display = "none";
      document.getElementById("loginForm").style.display = "block";
    });

    // Logout
    document.getElementById("logoutBtn").addEventListener("click", async () => {
      await signOut(auth);
      alert("Logged out!");
    });

    // Auth state listener
    onAuthStateChanged(auth, (user) => {
      if (user) {
        currentUser = user;
        showAppContainer();
        // Load user-specific data
        loadClients();
      } else {
        currentUser = null;
        showAuthContainer();
      }
    });

    // --- Add Charge ---
    async function addCharge(first, last, amount, remarks) {
      if (!currentUser) return;
      const id = generateClientId(first, last);
      const ref = doc(db, "users", currentUser.uid, "clients", id);
      try {
        const snap = await getDoc(ref);
        const c = snap.exists() 
          ? snap.data() 
          : { firstName: first, lastName: last, debit: 0, credit: 0, history: [] };

        c.history.push({
          date: new Date().toLocaleString(),
          debit: amount,
          credit: 0,
          method: "charge",
          remarks
        });

        await setDoc(ref, { 
          firstName: first, 
          lastName: last, 
          debit: (c.debit || 0) + amount, 
          credit: c.credit || 0, 
          history: c.history 
        }, { merge: true });

        alert(`✅ Charge of ${amount} added for ${first} ${last} (Client ID: ${id})`);
      } catch (err) {
        console.error("Firestore write failed:", err);
        alert("⚠️ Failed to save client record: " + err.message);
      }
    }

    // --- Add Payment ---
    async function addPayment(first, last, amount, method, remarks) {
      if (!currentUser) return;
      const id = generateClientId(first, last);
      const ref = doc(db, "users", currentUser.uid, "clients", id);
      try {
        const snap = await getDoc(ref);
        const c = snap.exists() 
          ? snap.data() 
          : { firstName: first, lastName: last, debit: 0, credit: 0, history: [] };

        c.history.push({
          date: new Date().toLocaleString(),
          debit: 0,
          credit: amount,
          method,
          remarks
        });

        await setDoc(ref, { 
          firstName: first, 
          lastName: last, 
          debit: c.debit || 0, 
          credit: (c.credit || 0) + amount, 
          history: c.history 
        }, { merge: true });

        alert(`✅ Payment of ${amount} recorded for ${first} ${last} (Client ID: ${id})`);
      } catch (err) {
        console.error("Firestore write failed:", err);
        alert("⚠️ Failed to save client record: " + err.message);
      }
    }

    // --- View Client Records (Modal) ---
    async function viewClient(id) {
      if (!currentUser) return;
      const ref = doc(db, "users", currentUser.uid, "clients", id);
      try {
        const snap = await getDoc(ref);
        if (snap.exists()) {
          const c = snap.data();
          const modal = document.getElementById("viewModal");
          const modalTitle = document.getElementById("modalTitle");
          const totalDebit = document.getElementById("totalDebit");
          const totalCredit = document.getElementById("totalCredit");
          const balance = document.getElementById("balance");
          const status = document.getElementById("status");
          const historyBody = document.getElementById("historyBody");

          modalTitle.textContent = `Records for ${c.firstName} ${c.lastName} (ID: ${id})`;
          totalDebit.textContent = (c.debit || 0).toFixed(2);
          totalCredit.textContent = (c.credit || 0).toFixed(2);
          const bal = (c.debit || 0) - (c.credit || 0);
          balance.textContent = bal.toFixed(2);
          status.textContent = bal > 0 ? "Outstanding" : "Paid";

          historyBody.innerHTML = "";
          c.history.forEach(h => {
            historyBody.insertAdjacentHTML("beforeend", `
              <tr>
                <td>${h.date}</td>
                <td>${h.debit.toFixed(2)}</td>
                <td>${h.credit.toFixed(2)}</td>
                <td>${h.method}</td>
                <td>${h.remarks}</td>
              </tr>
            `);
          });

          modal.style.display = "block";
        } else {
          alert("No records found for this client.");
        }
      } catch (err) {
        console.error("Error viewing client:", err);
        alert("⚠️ Unable to fetch client record (offline?).");
      }
    }

    // Expose viewClient to window for onclick
    window.viewClient = viewClient;

    // --- Load Clients (Realtime) ---
    function loadClients() {
      if (!currentUser) return;
      onSnapshot(collection(db, "users", currentUser.uid, "clients"), snap => {
        clients = {};
        snap.forEach(d => (clients[d.id] = d.data()));
        renderClients();
      });
    }

    // Function to highlight text
    function highlightText(text, query) {
      if (!query) return text;
      const regex = new RegExp(`(${query})`, 'gi');
      return text.replace(regex, '<mark>$1</mark>');
    }

    function renderClients() {
      const tbody = document.querySelector("#clientsTable tbody");
      if (!tbody) return;
      tbody.innerHTML = "";
      Object.entries(clients).forEach(([id, c]) => {
        const balance = (c.debit || 0) - (c.credit || 0);
        const status = balance > 0 ? "Outstanding" : "Paid";
        // --- Search filter by name OR remarks ---
        const fullName = `${c.firstName || ""} ${c.lastName || ""}`.toLowerCase();
        const remarksText = (c.history || []).map(h => h.remarks || "").join(" ").toLowerCase();

        if (searchQuery && !fullName.includes(searchQuery) && !remarksText.includes(searchQuery)) return;
        if (currentFilter !== "all" && status.toLowerCase() !== current






