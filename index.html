<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc, collection, onSnapshot, addDoc } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

const app = initializeApp({
  apiKey: "AIzaSyCrtGcFZVwP6dlsc_Bljr_yN-nu6hxihVg",
  authDomain: "client-payment-tracker-3572b.firebaseapp.com",
  projectId: "client-payment-tracker-3572b"
});

const auth = getAuth(app);
const db = getFirestore(app);

let currentUser = null, clients = {}, expenses = [], notes = '', userRole = null;

// Utility functions
const cid = n => n.toLowerCase().replace(/\s+/g, '_');
const formatDate = (isoString) => {
  if (!isoString) return '';
  const d = new Date(isoString);
  return `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
};
const highlight = (t, q) => !q ? t : t.replace(new RegExp(`(${q})`, 'gi'), '<span class="highlight">$1</span>');

// Get DOM elements (fixes module scoping issues)
const loginBtn = document.getElementById('loginBtn');
const signupBtn = document.getElementById('signupBtn');
const loginEmail = document.getElementById('loginEmail');
const loginPassword = document.getElementById('loginPassword');
const authSection = document.getElementById('authSection');
const appSection = document.getElementById('appSection');
const logoutBtn = document.getElementById('logoutBtn');
const clientSearchInput = document.getElementById('clientSearchInput');
const clientSearchBtn = document.getElementById('clientSearchBtn');
const clientFilter = document.getElementById('clientFilter');
const clientsBody = document.getElementById('clientsBody');
const chargeName = document.getElementById('chargeName');
const chargeAuto = document.getElementById('chargeAuto');
const chargeAmount = document.getElementById('chargeAmount');
const chargeStart = document.getElementById('chargeStart');
const chargeEnd = document.getElementById('chargeEnd');
const chargeRemarks = document.getElementById('chargeRemarks');
const addChargeBtn = document.getElementById('addChargeBtn');
const paymentSearch = document.getElementById('paymentSearch');
const paymentAuto = document.getElementById('paymentAuto');
const paymentClientName = document.getElementById('paymentClientName');
const paymentBalance = document.getElementById('paymentBalance');
const paymentAmount = document.getElementById('paymentAmount');
const paymentType = document.getElementById('paymentType');
const paymentMode = document.getElementById('paymentMode');
const paymentDate = document.getElementById('paymentDate');
const paymentRemarks = document.getElementById('paymentRemarks');
const addPaymentBtn = document.getElementById('addPaymentBtn');
const expenseDate = document.getElementById('expenseDate');
const expenseAmount = document.getElementById('expenseAmount');
const expenseDesc = document.getElementById('expenseDesc');
const expenseInvoice = document.getElementById('expenseInvoice');
const addExpenseBtn = document.getElementById('addExpenseBtn');
const viewExpenseStart = document.getElementById('viewExpenseStart');
const viewExpenseEnd = document.getElementById('viewExpenseEnd');
const viewExpenseBtn = document.getElementById('viewExpenseBtn');
const viewExpenseResult = document.getElementById('viewExpenseResult');
const reportStart = document.getElementById('reportStart');
const reportEnd = document.getElementById('reportEnd');
const generateReportBtn = document.getElementById('generateReportBtn');
const reportResult = document.getElementById('reportResult');
const notesTextarea = document.getElementById('notesTextarea');
const saveNotesBtn = document.getElementById('saveNotesBtn');
const notesDisplay = document.getElementById('notesDisplay');
const viewModal = document.getElementById('viewModal');
const viewTitle = document.getElementById('viewTitle');
const viewSummary = document.getElementById('viewSummary');
const viewBody = document.getElementById('viewBody');

// LOGIN
loginBtn.onclick = () => {
  const email = loginEmail.value.trim();
  const password = loginPassword.value.trim();
  if (!email || !password) return alert("Please enter email and password");
  signInWithEmailAndPassword(auth, email, password).catch(e => alert(`Login failed: ${e.message}`));
};

// SIGN UP
signupBtn.onclick = () => {
  const email = loginEmail.value.trim();
  const password = loginPassword.value.trim();
  if (!email || !password) return alert("Please enter email and password");
  if (password.length < 6) return alert("Password should be at least 6 characters");
  createUserWithEmailAndPassword(auth, email, password).then(() => {
    alert("Account created successfully! You can now log in.");
  }).catch(e => alert(`Signup failed: ${e.message}`));
};

onAuthStateChanged(auth, async u => {
  if (u) {
    currentUser = u;
    // Load user role
    const userDoc = await getDoc(doc(db, "users", currentUser.uid));
    userRole = userDoc.exists() ? userDoc.data().role || "user" : "user";
    
    authSection.style.display = "none";
    appSection.style.display = "block";
    loadClients();
    loadExpenses();
    loadNotes();
    
    // Show/hide admin report button based on role
    const adminBtn = document.querySelector('#toolbar button[onclick*="reportSection"]');
    if (adminBtn) {
      adminBtn.style.display = userRole === "admin" ? "inline-block" : "none";
    }
  } else {
    authSection.style.display = "block";
    appSection.style.display = "none";
    userRole = null;
  }
});

// CLIENTS
function loadClients() {
  onSnapshot(collection(db, "users", currentUser.uid, "clients"), snap => {
    clients = {};
    snap.forEach(d => clients[d.id] = d.data());
    renderClients();
  });
}

function renderClients() {
  const q = clientSearchInput.value.toLowerCase();
  const f = clientFilter.value;
  clientsBody.innerHTML = "";
  Object.values(clients).forEach(c => {
    const bal = (c.debit || 0) - (c.credit || 0);
    const s = bal > 0 ? "outstanding" : "paid";
    if (q && !c.name.toLowerCase().includes(q)) return;
    if (f !== "all" && f !== s) return;
    clientsBody.innerHTML += `
    <tr>
      <td>${highlight(c.name, q)}</td>
      <td class="${bal > 0 ? 'debit-red' : ''}">${c.debit || 0}</td>
      <td>${c.credit || 0}</td>
      <td class="${bal > 0 ? 'debit-red' : 'balance-paid'}">${bal}</td>
      <td>${s}</td>
      <td><button onclick="viewClient('${c.name}')">View</button></td>
    </tr>`;
  });
}

clientSearchBtn.onclick = renderClients;
clientFilter.onchange = renderClients;

// AUTOCOMPLETE CHARGE
chargeName.oninput = () => {
  chargeAuto.innerHTML = "";
  const q = chargeName.value.toLowerCase();
  Object.values(clients).forEach(c => {
    if (c.name.toLowerCase().includes(q)) {
      const d = document.createElement("div");
      d.className = "autocomplete-item";
      d.textContent = c.name;
      d.onclick = () => selectChargeClient(c.name);
      chargeAuto.appendChild(d);
    }
  });
};

function selectChargeClient(name) {
  chargeName.value = name;
  chargeAuto.innerHTML = "";
}

// ADD CHARGE
addChargeBtn.onclick = async () => {
  const name = chargeName.value;
  if (!name) return alert("Enter client name");
  const ref = doc(db, "users", currentUser.uid, "clients", cid(name));
  const s = await getDoc(ref);
  const c = s.exists() ? s.data() : { name, debit: 0, credit: 0, history: [] };
  c.history.push({ date: new Date().toISOString(), debit: +chargeAmount.value, credit: 0, method: "charge", remarks: chargeRemarks.value, start: chargeStart.value, end: chargeEnd.value });
  await setDoc(ref, { name, debit: c.debit + +chargeAmount.value, credit: c.credit, history: c.history });
  alert("Charge added");
  // Clear fields after save
  chargeName.value = '';
  chargeAmount.value = '';
  chargeStart.value = '';
  chargeEnd.value = '';
  chargeRemarks.value = '';
  chargeAuto.innerHTML = '';
};
  
// VIEW CLIENT
window.viewClient = name => {
  const c = clients[cid(name)];
  let d = 0, cr = 0;
  c.history.forEach(h => { d += h.debit || 0; cr += h.credit || 0 });
  const bal = d - cr;
  viewTitle.textContent = name;
  viewSummary.innerHTML = `Total Debit: ${d}<br>Total Credit: ${cr}<br>Balance: <span class="${bal > 0 ? 'debit-red' : 'balance-paid'}">${bal}</span>`;
  viewBody.innerHTML = "";
  // Sort history by date to process in order
  const sortedHistory = c.history.sort((a, b) => new Date(a.date) - new Date(b.date));
  let remainingPayment = 0; // Tracks how much payment is left to apply to charges
  sortedHistory.forEach(h => {
    let rowClass = '';
    if (h.debit > 0) {
      // It's a charge: Check if it's fully covered by remaining payment
      if (remainingPayment >= h.debit) {
        remainingPayment -= h.debit; // Fully covered, no highlight
      } else {
        rowClass = 'unpaid-row'; // Partially or not covered, highlight
        remainingPayment = 0; // Reset for next charges
      }
    } else if (h.credit > 0) {
      // It's a payment: Add to remaining payment for future charges
      remainingPayment += h.credit;
    }
    viewBody.innerHTML += `
    <tr class="${rowClass}">
      <td>${formatDate(h.date)}</td>
      <td>${h.debit || 0}</td>
      <td>${h.credit || 0}</td>
      <td>${h.method || ''}</td>
      <td>${h.mode || ''}</td>
      <td>${h.remarks || ''}</td>
      <td>${h.start || ''}</td>
      <td>${h.end || ''}</td>
    </tr>`;
  });
  // Add total row
  viewBody.innerHTML += `
    <tr style="font-weight: bold; background-color: #eee;">
      <td>Total</td>
      <td>${d}</td>
      <td>${cr}</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>`;
  viewModal.style.display = "block";
};
window.closeViewModal = () => viewModal.style.display = "none";

// AUTOCOMPLETE PAYMENT
paymentSearch.oninput = () => {
  paymentAuto.innerHTML = "";
  const q = paymentSearch.value.toLowerCase();
  Object.values(clients).forEach(c => {
    if (c.name.toLowerCase().includes(q)) {
      const d = document.createElement("div");
      d.className = "autocomplete-item";
      d.textContent = c.name;
      d.onclick = () => selectClient(c.name);
      paymentAuto.appendChild(d);
    }
  });
};

function selectClient(name) {
  const c = clients[cid(name)];
  let d = 0, cr = 0, remarks = [];
  c.history.forEach(h => {
    d += h.debit || 0; cr += h.credit || 0;
    if (h.debit > 0 && h.remarks) remarks.push(h.remarks);
  });
  const bal = d - cr;
  paymentClientName.value = name;
  paymentBalance.value = `Balance: ${bal}`;
  paymentRemarks.value = bal > 0 && remarks.length ? remarks.join(', ') : '';
  paymentAuto.innerHTML = "";
}

// PAYMENT
addPaymentBtn.onclick = async () => {
  const name = paymentClientName.value;
  const ref = doc(db, "users", currentUser.uid, "clients", cid(name));
  const s = await getDoc(ref);
  const c = s.data();
  c.history.push({ date: paymentDate.value, debit: 0, credit: +paymentAmount.value, method: "payment", mode: paymentMode.value, type: paymentType.value, remarks: paymentRemarks.value });
  await setDoc(ref, { ...c, credit: c.credit + +paymentAmount.value });
  alert("Payment added");
  // Clear form after save
  paymentSearch.value = '';
  paymentClientName.value = '';
  paymentBalance.value = '';
  paymentAmount.value = '';
  paymentType.value = '';
  paymentMode.value = '';
  paymentDate.value = '';
  paymentRemarks.value = '';
};

// EXPENSE
function loadExpenses() {
  onSnapshot(collection(db, "users", currentUser.uid, "expenses"), snap => {
    expenses = []; snap.forEach(d => expenses.push(d.data()));
  });
}
addExpenseBtn.onclick = async () => {
  await addDoc(collection(db, "users", currentUser.uid, "expenses"), {
    date: expenseDate.value, amount: +expenseAmount.value, desc: expenseDesc.value, invoice: expenseInvoice.value
  });
  alert("Expense saved");
};

// VIEW EXPENSES
viewExpenseBtn.onclick = () => {
  const s = new Date(viewExpenseStart.value);
  const e = new Date(viewExpenseEnd.value);
  const filtered = expenses.filter(x => new Date(x.date) >= s && new Date(x.date) <= e);
  let html = "<table><thead><tr><th>Date</th><th>Amount</th><th>Description</th><th>Invoice</th></tr></thead><tbody>";
  filtered.forEach(x => html += `<tr><td>${formatDate(x.date)}</td><td>${x.amount}</td><td>${x.desc}</td><td>${x.invoice || ''}</td></tr>`);
  html += "</tbody></table>";
  viewExpenseResult.innerHTML = html;
};

// NOTES
function loadNotes() {
  const userRef = doc(db, "users", currentUser.uid);
  getDoc(userRef).then(docSnap => {
    if (docSnap.exists()) {
      notes = docSnap.data().content || '';
      notesTextarea.value = notes;
      notesDisplay.innerHTML = notes.replace(/\n/g, '<br>');
    }
  }).catch(e => console.error("Error loading notes:", e));
}

// Edit/Save Notes
let isEditingNotes = false;
const editNotesBtn = document.createElement('button');
editNotesBtn.textContent = 'Edit';
editNotesBtn.style.marginLeft = '10px';
notesTextarea.parentNode.insertBefore(editNotesBtn, notesTextarea.nextSibling);

editNotesBtn.onclick = () => {
  if (isEditingNotes) {
    // Save mode
    saveNotes();
    notesTextarea.readOnly = true;
    editNotesBtn.textContent = 'Edit';
    isEditingNotes = false;
  } else {
    // Edit mode
    notesTextarea.readOnly = false;
    notesTextarea.focus();
    editNotesBtn.textContent = 'Save';
    isEditingNotes = true;
  }
};

async function saveNotes() {
  if (!currentUser) return alert("Please log in to save notes.");
  notes = notesTextarea.value;
  const userRef = doc(db, "users", currentUser.uid);
  try {
    await setDoc(userRef, { content: notes }, { merge: true }); // Use merge to update only the content field
    alert("Notes saved successfully!");
    notesDisplay.innerHTML = notes.replace(/\n/g, '<br>');
  } catch (e) {
    alert(`Failed to save notes: ${e.message}`);
  }
}

// REPORT
generateReportBtn.onclick = () => {
  if (userRole !== "admin") {
    alert("Access denied: Admin privileges required.");
    return;
  }

// REPORT
generateReportBtn.onclick = () => {
  const s = new Date(reportStart.value);
  const e = new Date(reportEnd.value);
  let cashSales = 0, bankTransferSales = 0, creditCardSales = 0, otherSales = 0;
  Object.values(clients).forEach(c => c.history.forEach(h => {
    const d = new Date(h.date);
    if (h.credit && d >= s && d <= e) {
      if (h.type === "Cash") cashSales += h.credit;
      else if (h.type === "Bank Transfer") bankTransferSales += h.credit;
      else if (h.type === "Credit Card") creditCardSales += h.credit;
      else otherSales += h.credit;
    }
  }));
  // Merge otherSales into cashSales
  cashSales += otherSales;
  otherSales = 0;
  const totalCollection = cashSales + bankTransferSales + creditCardSales + otherSales;
  const totalExpenses = expenses.filter(x => new Date(x.date) >= s && new Date(x.date) <= e).reduce((a, b) => a + b.amount, 0);
  const netSales = totalCollection - totalExpenses;
  const cashOnHand = netSales - (bankTransferSales + creditCardSales + otherSales);
  reportResult.innerHTML = `
    <strong>Sales Breakdown:</strong><br>
    Total Cash Sales: ${cashSales}<br>
    Total Bank Transfer Sales: ${bankTransferSales}<br>
    Total Credit Card Sales: ${creditCardSales}<br>
    Total Other Sales: ${otherSales}<br><br>
    <strong>Total Collection: ${totalCollection}</strong><br>
    <strong>Total Expenses: ${totalExpenses}</strong><br>
    <strong>Net Sales: ${netSales}</strong><br>
    <strong>Cash on Hand: ${cashOnHand}</strong>
  `;
};

logoutBtn.onclick = () => signOut(auth);
window.showSection = id => {
  document.querySelectorAll(".section").forEach(s => s.style.display = "none");
  document.getElementById(id).style.display = "block";
  // Highlight active toolbar button
  document.querySelectorAll("#toolbar button").forEach(b => b.classList.remove("active"));
  const activeBtn = Array.from(document.querySelectorAll("#toolbar button")).find(b => b.onclick.toString().includes(id));
  if (activeBtn) activeBtn.classList.add("active");
};
</script>


